# 유니티 C# 명령어

---

## 🖊️ 페이지 소개

---

- 못해도 내가 한번쯤 봐온 명령어들을 전부 정리한 페이지.
- 정리된 명령어 외에도 수없이 많으니 적당히 사용해가면서 알아가도록 한다.
- **특히나 명령어에서 주의 할건** **대소문자나 컴마( . ) 구분에 주의하자.**

### 🎁 유니티 이벤트 메서드

---

- 유니티가 지정한 특정 기능을 수행하는 메서드. 이름만 치면 형식이 자동으로 작성된다.

- 초기 실행 함수
    - Awake() : 스크립트가 **최초로 활성화될 때** 1번만 실행. Start()보다 우선순위가 높다.
    - **Start** : Awake()보단 늦게 호출되는 최초 1번 실행 메서드.

- 반복 실행 함수
    - **Update** : 1프레임에 1번씩 실행되는 메서드. cpu의 사양에 따라 1초에 실행하는 실행 주기의 빈도가 달라진다. 물리 연산 외의 수시로 바뀌는 게임 로직들을 넣는다.
    - FixedUpdate : 1초에 약 50번을 cpu의 사양 상관 없이 실행. 따라서 cpu의 사용이 많아 물리 연산에 관련된 로직만 넣는다.
    - LateUpdate : 업데이트가 끝날 때 실행된다.

- 조건 실행 함수
    - OnEnable() : 스크립트가 **활성화 될 때 마다** 실행.
    - OnDisable() : 스크립트가 **비활성화 될 때 마다** 실행.
    - OnDestroy : 오브젝트가 삭제될 때 실행.
    - **OnCollisionEnter** : 물리적 충돌시 실행된다.

## 🚨 명령어

---

- **Debug.Log();** : 콘솔창에 메세지 출력.

### ⌨️ 키보드 마우스 입력

---

- **Input** : 게임 내 입력을 관리하는 클래스. 불 자료형이다.
    - anyKey : 아무 키나 누르면 실행.
    - **GetKey** : 키보드 버튼을 입력받으면 실행.
        - -**Down : 눌렀을 때 true.**
        - -Stay : 누르고 있는 상태에서 true.
        - -Up : 눌렀다 뗐을 때 true.
        - **(KeyCode.키 이름) :** KeyCode명령어로 어떤 키인지 인식.
    - **GetMouseButton(0/1)** : 0이면 왼쪽 클릭, 1이면 오른쪽 클릭.
- **유니티 상단 메뉴 Edit → Projrct Settings → Input(Input Manager)에서 Button 설정 가능.**
    - 각 이동의 키들을 설정해두고 **GetButton(”버튼 이름”)**을 입력하면 인식 가능.
    - **Size**를 늘리면 내가 정하고 싶은 기능의 버튼도 생성 가능.
- **GetAxis** : 수평, 수직 버튼을 입력받으면 float값을 생성. 가중치가 있다.(= 시작 기준 가속도가 붙음)
    - AsisRaw : 가중치 없이 무조건 1 / -1 반환.
    - 두 키 동시에 누르면 0 반환.

### 🚄 오브젝트 이동

---

- **Vector3 vec = new Vector3(0, 0, 0);
transform.Translate(vec);**

      과 같이 입력하면 위치값을 초기화 가능.

- **transform**은 모든 오브젝트에 기본적으로 붙어있는 것이라 유니티는 이를 딱히 네임스페이스 선언이 없이도 사용할 수 있도록 해줬다.
- **Translate** : **이동의 의미**. vec만큼 이동하는 명령어이다.
    - **Vector3.MoveToward(현제 위치, 목표 위치, 속도)** : 괄호의 조건에 따라 등속이동을 한다.
    - **Vector3.MoveDamp(현제 위치, 목표 위치, 참조 속도, 속도) :** 괄호의 조건에 따라 마지막 속도에 반비례하여 속력이 증가. 갈수록 느려지는 움직임을 보인다.
    - **Vector3.MoveLerp(현제 위치, 목표 위치, 속도) :** 매우 속도가 빠른 직선 움직임을 보인다.
    - **Vector3.Slerp(현제 위치, 목표 위치, 속도) :** 호를 그리며 이동한다. 다른건 Lerp과 같다.

## 📓 컴포넌트

---

- 물리 엔진
    - **RigidBody** : 물리효과를 받기 위한 컴포넌트. 중력의 영향을 받는다. Mass값이 크면 클수록 물체의 무게가 무거워진다.
        - Use Gravity : 중력의 영향을 받음.
        - **Is Kinematic** : 외부 물리 효과를 무시. 장애물 혹은 움직이는 함정을 만들 때 유용.
        - c# 스크립트를 이용한 RigidBody 활용
            - GetComponent<Rigidbody>() : RigidBody에 연동. 입력된 값에 따라 RigidBody의 값이 변한다.
            - velocity :  속력를 변화시키는 함수. 벡터값의 지정에 따라 변한다.
            - **AddForce** : 괄호의 방향과 크기로 힘을 줌.
            - ForceMode : 힘을 주는 방식.(가속, 무게반영)
            - AddTorque : 회전력. 입력 축 방향으로 회전력 주기
            
            ```csharp
            using System.Collections;
            using System.Collections.Generic;
            using UnityEngine;
            
            public class MyBall : MonoBehaviour
            {
                Rigidbody rigid; //RigidBody 타입 변수 rigid 생성.
                void Start()
                {
                    rigid = GetComponent<Rigidbody>(); //RigidBody에 연동.
                }
            
                void FixedUpdate()
                {
                    rigid.velocity = new Vector3(2, 4, -1); // velocity 속력 변화.
            
                    if(Input.GetButton("Jump"))
                    {
                        rigid.AddForce(Vector3.up * 2, ForceMode.Impulse);
            						// AddForce 괄호의 방향과 크기로 힘을 줌.
            						//ForceMode 힘을 주는 방식.(가속, 무게반영)
                    ***Vector3 vec = new Vector3(Input.GetAxisRaw("Horizontal"), 0, Input.GetAxisRaw("Vertical"));*** // 이동식은 이게 좋은 듯.
                    rigid.AddForce(vec, ForceMode.Impulse); // 이거 좀 지리네
            
                    rigid.AddTorque(Vector3.back); //AddTorque 회전력. 입력 축 방향으로 회전력 주기
                    
                }
            }
            ```
            
    - **Collider** : 물리효과를 받기 위한 컴포넌트. 물체 끼리의 충돌에 영향을 받는다.
    - **Material** : 오브젝트의 표면 재질을 결정하는 컴포넌트. 재질 편집은 Assets에서 새로 만들어야 가능. 다만 이것은 **눈에 보이는 재질만을 다룬다.**
    - **Physics Material** : 탄성과 마찰을 다루는 **물리 컴포넌트**. Material의 경우 오브젝트의 눈에 보이는 부분을 다룬다면 이 컴포넌트는 **실제 물리에서 적용되는 재질을 다룬다.**
        - Bounciness : 탄성 크기. 0~1까지 있다.
        - Friction : 마찰력. 낮을수록 많이 미끄러짐.
    
    ### 🔍 FindobjectType()
    
    ---
    
    - FindobjectType() : hierarchy 창의 모든 오브젝트를 검색해서 조건에 맞는 오브젝트를 찾도록 해주는 메서드.
        - 어째선지 유니티에선 new를 이용한 인스턴스 생성이 안되더라
        
        ```csharp
        //예제
        BossSpowner spon = FindObjectOfType<BossSpowner>();
        spon.forspon = true; //spon 안에 있는 변수 forspon을 조작하는 코드.
        ```
        
    - 이 메서드의 단점이라면 모든 오브젝트를 검색하기에 **결코 가볍지 않다는 거다**. 따라서 사용할 때는 Start와 같은 **한번만 실행되는 메서드에서 활용**하자.
    
    ### 👁️ [SerializeField]
    
    ---
    
    - [SerializeField] private : private의 접근자를 가지며 **인스펙터 창에 표시되게 하는 접근자**.
        - 보통 인스펙터에선 private 변수는 표시되지 않기에 보여지기 위해선 public을 써야된다.
            - 다만 객체 지향 언어엔 **캡슐화**라는 룰이 있어, 필요 이상의 정보는 공개되어선 안된다.
        - 이  때문에 public은 막 사용해선 안되는데, **모습을 감추면서 유니티의 인스펙터에 표시해야할 상황**이 생길 경우 [SerializeField]를 사용한다.
    
    ### ⏱️ Invoke
    
    ---
    
    - **일정 시간에 함수를 호출** 시키는 메서드.
    - 인보크는 Update와 비슷하지만 **비활성화 상태일때에도 발동**되는 메서드이다.
    - Invoke**("함수명", 실행 시간)** 의 형태로 사용한다.
    - Invoke : 해당 시간에 한번만 호출
    - InvokeRepeating : 반복적으로 호출. 이 땐 **("함수명", 지연시간, 실행 시간)** 의 형태이다.
    - CancelInvoke : 인보크를 취소. **("함수명")의 형태이지만 함수명을 안쓰면 모든 인보크가 종료된다.**
    - 인보크는 문자열로 함수명을 받기 때문에 문자열을 해독하는데에 시간이 오래걸린다. 따라서 **코루틴을 이용함이** 유지보수나 최적화 측면에서 좋다.
    
    ### 🔂 Corutine
    
    ---
    
    [코루틴](%E1%84%8B%E1%85%B2%E1%84%82%E1%85%B5%E1%84%90%E1%85%B5%20C#%20%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5%203d42673102cd46de875843628c8f8e05/%E1%84%8F%E1%85%A9%E1%84%85%E1%85%AE%E1%84%90%E1%85%B5%E1%86%AB%2090646a2c7de142ad862255f2a22fb6a7.md)
    
    ### 🎞️ SceneManager
    
    ---
    
    - **씬 전환**을 도와주는 네임 스페이스.
    - buildindex : 씬에 매겨진 번호.
    - **LoadScene(씬 이름 or 번호)** : 해당 씬으로 **이동.**

## 📺 UI

---

- Canvas : UI의 배치를 할 수 있는 공간. 캔버스 전체가 유저가 보는 화면에 띄워진다.
- Text : 간단한 텍스트 출력 기능.
- Button : 버튼 기능. 안의 텍스트도 조정 가능하며 모양도 조정 가능하다.
    - OnClick() : 버튼 클릭 시 호출되는 이벤트 함수